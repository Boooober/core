{"fileName":"voting/Voting51.sol","name":"ProposalDoneReceiver","abi":[{"constant":false,"inputs":[{"name":"_index","type":"uint256"}],"name":"proposalDone","outputs":[],"payable":false,"type":"function"}],"bin":"","opcodes":"","source":"pragma solidity ^0.4.4;\nimport 'common/Object.sol'; \nimport 'token/Token.sol'; \n\ncontract ProposalDoneReceiver {\n    function proposalDone(uint _index);\n}\n\n/**\n * @dev The 51% voting\n */\ncontract Voting51 is Object {\n    Token                public voting_token;\n    ProposalDoneReceiver public receiver;\n\n    address[]               public proposal_target;\n    mapping(uint => uint)   public start_time;\n    mapping(uint => uint)   public end_time;\n    mapping(uint => string) public description;\n\n    mapping(uint => uint)   public total_value;\n    mapping(uint => mapping(address => uint)) public voter_value;\n\n    uint public current_proposal = 0;\n\n    event ProposalDone(uint indexed index);\n    event ProposalNew(uint indexed index);\n\n    /**\n     * @dev Create voting contract for given voting token\n     * @param _voting_token is a token used for voting actions\n     * @param _receiver is a receiver for proposal done actions\n     */\n    function Voting51(address _voting_token, address _receiver) {\n        voting_token = Token(_voting_token);\n        receiver     = ProposalDoneReceiver(_receiver);\n    }\n\n    /**\n     * @dev Append new proposal for voting\n     * @param _target is a proposal target\n     * @param _description is a proposal description\n     * @param _start_time is a start time of voting\n     * @param _duration_sec is a duration of voting\n     * @notice only voters (accounts with positive voting token balance) can call it\n     */\n    function proposal(address _target, string _description,\n                      uint _start_time, uint _duration_sec) onlyOwner {\n        description[proposal_target.length] = _description;\n        start_time[proposal_target.length]  = _start_time;\n        end_time[proposal_target.length]    = _start_time + _duration_sec;\n        proposal_target.push(_target);\n        ProposalNew(proposal_target.length-1);\n    }\n\n    /**\n     * @dev Voting for current proposal\n     * @param _count is how amount of `voting_token` used\n     * @notice `voting_token` should be approved for voting\n     */\n    function vote(uint _count) {\n        // Check for no proposal exist\n        if (proposal_target[current_proposal] == 0\n         || now < start_time[current_proposal]) throw;\n\n        // Check for end of voting time\n        if (now > end_time[current_proposal]) {\n            ++current_proposal;\n            return;\n        }\n\n        // Thransfer token\n        if (!voting_token.transferFrom(msg.sender, this, _count)) throw;\n\n        // Increment values\n        total_value[current_proposal]             += _count;\n        voter_value[current_proposal][msg.sender] += _count;\n\n        var voting_limit = voting_token.totalSupply() / 2; // 50%\n        // Check vote done\n        if (total_value[current_proposal] > voting_limit) {\n            ProposalDone(current_proposal);\n            receiver.proposalDone(current_proposal++);\n        }\n    }\n\n    /**\n     * @dev Refund voting tokens\n     * @param _proposal is a proposal id\n     * @param _count is how amount of tokens should be refunded\n     */\n    function refund(uint _proposal, uint _count) {\n        if (voter_value[_proposal][msg.sender] < _count) throw;\n        if (!voting_token.transfer(msg.sender, _count)) throw;\n        voter_value[_proposal][msg.sender] -= _count;\n    }\n}\n","abiDocs":[{"constant":false,"inputs":[{"name":"_index","type":"uint256"}],"name":"proposalDone","outputs":[],"payable":false,"type":"function","signature":"proposalDone(uint256)","signatureHash":"6ff666d2"}]}
